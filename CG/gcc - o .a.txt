#include <GL/glut.h>
#include <iostream>
#include <math.h>

using namespace std;

int ch = 0;

void display(int x, int y)
{
    glColor3f(0,0,0);
    glPointSize(2);
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
}

void displaydotted(int x, int y)
{
    glColor3f(0,0,0);
    glPointSize(2);
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
}

void displaydashed(int x, int y)
{
    glColor3f(0,0,0);
    glPointSize(3);
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
}

void displaysolid(int x, int y)
{
    glColor3f(0,0,0);
    glPointSize(6);
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
}

void SimpleLine(int x1, int y1, int x2, int y2){
	float dx = x2 - x1;
	float dy = y2 - y1;

	int steps;
	
	if(abs(dx) >= abs(dy)){
		steps = abs(dx);	
	}
	else{
		steps = abs(dy);
	}
	
	float Xin = dx / (float) steps;
	float Yin = dy / (float) steps;
	float x = x1;
	float y = y1;
	
	for(int i=0; i<=steps; i++){
		display(x, y);
		x = x + Xin;
		y = y + Yin;
	}
	glFlush();
}

void DottedLine(int x1, int y1, int x2, int y2){
	float dx = x2 - x1;
	float dy = y2 - y1;

	int steps;
	
	if(abs(dx) >= abs(dy)){
		steps = abs(dx);	
	}
	else{
		steps = abs(dy);
	}
	
	float Xin = dx / (float) steps;
	float Yin = dy / (float) steps;
	float x = x1;
	float y = y1;
	
	for(int i=0; i<=steps; i++){
		if(i % 6 == 0){
			displaydotted(x, y);
		}
		x = x + Xin;
		y = y + Yin;
	}
	glFlush();
}

void DashLine(int x1, int y1, int x2, int y2){
	float dx = x2 - x1;
	float dy = y2 - y1;

	int steps;
	
	if(abs(dx) >= abs(dy)){
		steps = abs(dx);	
	}
	else{
		steps = abs(dy);
	}
	
	float Xin = dx / (float) steps;
	float Yin = dy / (float) steps;
	float x = x1;
	float y = y1;
	
	for(int i=0; i<=steps; i++){
		if(i % 8 > 4){
			displaydashed(x, y);
		}
		x = x + Xin;
		y = y + Yin;
	}
	glFlush();
}

void SolidLine(int x1, int y1, int x2, int y2){
	float dx = x2 - x1;
	float dy = y2 - y1;

	int steps;
	
	if(abs(dx) >= abs(dy)){
		steps = abs(dx);	
	}
	else{
		steps = abs(dy);
	}
	
	float Xin = dx / (float) steps;
	float Yin = dy / (float) steps;
	float x = x1;
	float y = y1;
	
	for(int i=0; i<=steps; i++){
		displaydashed(x, y);
		x = x + Xin;
		y = y + Yin;
	}
	glFlush();
}

void mouse(int button, int state, int x, int y)
{
    static int x1, y1, pt = 0;
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
    {
        if (pt == 0)
        {
            x1 = x;
            y1 = y;
            pt = pt + 1;
        }
        else
        {
            if (ch == 1)
            {
                SimpleLine(x1, y1, x, y);
            }
            else if (ch == 2)
            {
            	DottedLine(x1, y1, x, y);
            }
            else if (ch == 3)
            {
                DashLine(x1, y1, x, y);
            }
            else if(ch == 4) 
			{
                SolidLine(x1, y1, x, y);
            }
            x1 = x;
            y1 = y;
        }
    }
    else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN){
    	pt = 0;	
	}
    glFlush();
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
		case 's':
		{
			ch = 1;
			cout << "Simple Line is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 'd':
		{
			ch = 2;
			cout << "Dotted Line is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 'D':
		{
			ch = 3;
			cout << "Dashed Line is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 'S':
		{
			ch = 4;
			cout << "Solid Line is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
    }
    glutPostRedisplay();
}

void initialize()
{
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT);
    gluOrtho2D(0, 600, 600, 0);
}

void initialaxis(){
    glColor3f(0,0,0);
    glLineWidth(2);
    glBegin(GL_LINES);
    glVertex2i(300, 0);
    glVertex2i(300, 600);
    glVertex2i(0, 300);
    glVertex2i(600, 300);
    glEnd();
	glFlush();
	glutKeyboardFunc(keyboard);
}

int main(int argc, char **argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE);
    glutInitWindowSize(600, 600);
    glutInitWindowPosition(800, 100);
    glutCreateWindow("DDA Algorithm");
    initialize();
    cout << "Choose your Line type: " << endl;
    cout << "--------------------------------------------" << endl;
    cout << "s => simple" << endl;
    cout << "d => dotted" << endl;
    cout << "D => Dashed" << endl;
    cout << "S => Solid" << endl;
    cout << "--------------------------------------------" << endl;
    glutDisplayFunc(initialaxis);
    glutMainLoop();
    return 0;
}

#include <GL/freeglut.h> 
#include <iostream>

int r, xc, yc, x, y; 
float p;

void putPixel(int px, int py)
{

glBegin(GL_POINTS); 
glVertex2f((float)px, (float)py);
glEnd();
}


void plotPoints(int px, int py)
{

putPixel(xc + px, yc + py); 
putPixel(xc + py, yc + px); 
putPixel(xc + py, yc - px); 
putPixel(xc + px, yc - py); 
putPixel(xc - px, yc - py); 
putPixel(xc - py, yc - px); 
putPixel(xc - px, yc + py); 
putPixel(xc + py, yc - px); 
putPixel(xc - py, yc + px);
}


void drawCircle()
{

glBegin(GL_LINES); 
glVertex2f(-640.0F, 0);
glVertex2f(640.0F, 0); 
glVertex2f(0, -480.0F); 
glVertex2f(0, 480.0F); 
glEnd();
p = 1.25F - (float)r; 
x = 0, y = r;
while (x < y) { 
plotPoints(x, y); 
if (p < 0) {
p += 2.0F * (float)x + 1.0F;

}
else if (p >= 0) {
--y;
p += 2.0F * (float)(x - y) + 1.0F;

}
++x;
}

glFlush();
}
void init()
{

glOrtho(-640.0, 640.0, -480.0, 480.0, -1.0, 1.0); 
glClearColor(0.0F, 0.0F, 0.0F, 1.0F);
glClear(GL_COLOR_BUFFER_BIT); 
glColor3f(1.0F, 1.0F, 1.0F);
}


int main(int argc, char **argv)
{

std::cout << "Enter radius: "; 
std::cin >> r;
std::cout << "Enter X coordinate of center: "; 
std::cin >> xc;
std::cout << "Enter Y coordinate of center: "; 
std::cin >> yc;
r = r * 16; 
xc = xc * 16; 
yc = yc * 16;
glutInit(&argc, argv); 
glutInitDisplayMode(GLUT_SINGLE); 
glutInitWindowSize(640, 480);
glutInitWindowPosition(400, 150); 
glutCreateWindow("Bresenham's Circle Drawing Algorithm"); 
init();
glutDisplayFunc(drawCircle);
glutMainLoop();
return 0;
}

#include <iostream>
#include <math.h>
#include <time.h>
#include <GL/glut.h>

using namespace std;

void delay(float ms){
    clock_t goal = ms + clock();
    while(goal>clock());
}

void init(){
    glClearColor(1.0,1.0,1.0,0.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0,640,0,480);
}

void bound_it(int x, int y, float* fillColor, float* bc){
    float color[3];
    glReadPixels(x,y,1.0,1.0,GL_RGB,GL_FLOAT,color);
    if((color[0]!=bc[0] || color[1]!=bc[1] || color[2]!=bc[2])&&(
     color[0]!=fillColor[0] || color[1]!=fillColor[1] || color[2]!=fillColor[2])){
        glColor3f(fillColor[0],fillColor[1],fillColor[2]);
        glBegin(GL_POINTS);
            glVertex2i(x,y);
        glEnd();
        glFlush();
        bound_it(x+1,y,fillColor,bc);
        bound_it(x-2,y,fillColor,bc);
        bound_it(x,y+2,fillColor,bc);
        bound_it(x,y-2,fillColor,bc);
    }
}

void mouse(int btn, int state, int x, int y){
    y = 480-y;
    if(btn==GLUT_LEFT_BUTTON)
    {
        if(state==GLUT_DOWN)
        {
            float bCol[] = {1,0,0};
            float color[] = {0,0,1};
            //glReadPixels(x,y,1.0,1.0,GL_RGB,GL_FLOAT,intCol);
            bound_it(x,y,color,bCol);
        }
    }
}

void world(){
    glLineWidth(3);
    glPointSize(2);
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1,0,0);
    glBegin(GL_LINE_LOOP);
        glVertex2i(150,100);
        glVertex2i(300,300);
        glVertex2i(450,100);
    glEnd();
    glFlush();
}

int main(int argc, char** argv){
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(640,480);
    glutInitWindowPosition(200,200);
    glutCreateWindow("Boundary Fill Algorithm");
    glutDisplayFunc(world);
    glutMouseFunc(mouse);
    init();
    glutMainLoop();
    return 0;
}


#include <iostream>
#include <math.h>
#include <GL/glut.h>
#include <list>

using namespace std;


void init(){
    glClearColor(1.0,1.0,1.0,1.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0,640,0,480);
}

int enter = 1, sz, gymin=480, gymax=0, parity=0;

float** pts;

float R = 1.0, G = 0.0, B = 0.0;

class points{
    int x;
    int y;
    public:
    points(int x,int y){
        this->x = x;
        this->y = y;
    }

    int getx(){
        return x;
    }

    int gety(){
        return y;
    }
};

list <points*> in;

void flip(){
    if(parity==0)
        parity = 1;
    else
        parity = 0;
}

class lines{
    int ymin;
    int ymax;
    float m;
    int xmin;
    int c;
    public:
    lines(int x1, int x2, float x3, int x4, int x5){
        ymin = x1;
        ymax = x2;
        m = x3;
        xmin = x4;
        c = x5;
    }
    int getymin(){return ymin;}
    int getymax(){return ymax;}
    float getm(){return m;}
    int getxmin(){return xmin;}
    int getc(){return c;}
};

lines** line;

void fillStrip(int y, int xstart, int xend){
    glColor3f(R,G,B);
    glBegin(GL_POINTS);
        glVertex2i(xstart,y);
        glVertex2i(xend,y);
    glEnd();
    glFlush();
    //glColor3f(R,G,B);
    if(parity==1){
        glBegin(GL_POINTS);
            for(int i=xstart+1;i<xend;i++)
                glVertex2i(i,y);
        glEnd();
        glFlush();
    }
}

void scanFill(){
    int sline = gymin;
    int plausibleLines = 0;

    while(sline<=gymax){
        lines** temp = new lines*[sz];

        // find plausible lines

        for(int i=0;i<sz;i++){
            if(sline<=line[i]->getymax() && sline>=line[i]->getymin())
            {
                temp[plausibleLines] = line[i];
                plausibleLines++;
            }
        }


        // kill if only one line

        if(plausibleLines==1)
        {
            cout<<"ERR::Require a Closed Figure";
            exit(0);
        }

        // find all intersection points

        list <int> intersect;

        for(int i=0;i<plausibleLines;i++){
            int xintersect;

            if(sline==temp[i]->getymax())
                continue;

            xintersect = (sline-temp[i]->getc())/temp[i]->getm();

            intersect.push_front(xintersect);
        }

        // sort

        intersect.sort();

        // plot the points

        while(intersect.size()>0){
            int start = intersect.front();
            flip();
            intersect.pop_front();
            int end = intersect.front();
            fillStrip(sline,start,end);
        }

        plausibleLines = 0;
        sline++;
    }

}

void computeGlobalVars(){

    //compute gloabl vars

    for(int i=0;i<sz;i++)
        if(gymin>line[i]->getymin())
            gymin = line[i]->getymin();
    for(int i=0;i<sz;i++)
        if(gymax<line[i]->getymax())
            gymax = line[i]->getymax();
}


void formLines(){

    //create line from the points and omit horizontal lines

    line = new lines*[sz];

    for(int i=0;i<sz;i++)
    {
        int q1[2],q2[2];
        float mm;
        if(i!=sz-1){
            q1[0] = pts[i][0]; q1[1]=pts[i][1];
            q2[0] = pts[i+1][0]; q2[1]=pts[i+1][1];
            mm = (pts[i+1][1]-pts[i][1])/(pts[i+1][0]-pts[i][0]);
        }
        else{
            q1[0] = pts[i][0]; q1[1]=pts[i][1];
            q2[0] = pts[0][0]; q2[1]=pts[0][1];
            mm = (pts[0][1]-pts[i][1])/(pts[0][0]-pts[i][0]);
        }
        if(q1[0]==q2[0] && q2[1]==q1[1])
        {
            cout<<"ERR::SAME POINTS";
            exit(0);
        }
        int ymn,ymx,xmn,cc;
        if(q2[1]<q1[1]){
            ymn = q2[1];
            ymx = q1[1];
        }
        else{
            ymn = q1[1];
            ymx = q2[1];
        }
        if(q1[0]<q2[0])
            xmn = q1[0];
        else
            xmn = q2[0];

        cc = q1[1] - (mm*q1[0]);

        if(mm!=0)
            line[i] = new lines(ymn,ymx,mm,xmn,cc);
        //cout<<"LINE "<<i<<" ymin "<<line[i]->getymin()<<" ymax "<<line[i]->getymax()<<" slope "<<line[i]->getm()<<" xmin "<<line[i]->getxmin()<<" c "<<line[i]->getc()<<endl;
    }

    computeGlobalVars();
}

void drawPolygon(){

    //draw polygon and create the points array

    glBegin(GL_LINE_LOOP);
    pts = new float*[in.size()];
    for(int i=0; i<in.size(); i++){
        pts[i] = new float[2];
    }
    sz = in.size();
    while(in.size()>0){
        points* temp = in.front();
        pts[in.size()-1][0] = temp->getx();
        pts[in.size()-1][1] = temp->gety();
        glVertex2i(temp->getx(),temp->gety());
        in.pop_front();
    }
    glEnd();
    glFlush();
    formLines();
}

void rgb(float r, float g, float b){
    R = (r * 3.92)/1000;
    G = (g * 3.92)/1000;
    B = (b * 3.92)/1000;
    glColor3f(R,G,B);
    glBegin(GL_POLYGON);
        glVertex2i(0,0);
        glVertex2i(20,0);
        glVertex2i(20,20);
        glVertex2i(0,20);
    glEnd();
    glFlush();
}

void key(unsigned char key_t, int x, int y){
    if(key_t=='d'){
        enter = 0;
        drawPolygon();
    }
    if(key_t<=57 && key_t>=48){
        int val = key_t - 48;
        switch(val){
            case 0: rgb(26.0, 188.0, 156.0);break;
            case 1: rgb(46.0, 204.0, 113.0);break;
            case 2: rgb(52.0, 152.0, 219.0);break;
            case 3: rgb(155.0, 89.0, 182.0);break;
            case 4: rgb(52.0, 73.0, 94.0);break;
            case 5: rgb(255.0, 255.0, 255.0);break;
            case 6: rgb(255.0, 0.0, 0.0);break;
            case 7: rgb(231.0, 76.0, 60.0);break;
            case 8: rgb(236.0, 240.0, 241.0);break;
            case 9: rgb(149.0, 165.0, 166.0);break;
        }
    }
    if(key_t=='s'){
        enter = 1;
        scanFill();
        in.empty();
    }
}

void drag_start(GLint x, GLint y){
    y = 480-y;
    glPointSize(4);
    glBegin(GL_POINTS);
        glVertex2i(x,y);
    glEnd();
    glFlush();
    glPointSize(2);
}


void mouse(int btn, int state, int x, int y){
    y = 480-y;
    if(btn==GLUT_LEFT_BUTTON)
    {
        if(state==GLUT_DOWN)
        {
            if(enter){
                points* temp = new points(x,y);
                in.push_front(temp);
                glBegin(GL_POINTS);
                    glVertex2i(x,y);
                glEnd();
                glFlush();
            }
        }
    }
}

void world(){
    glPointSize(2);
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1,0,0);
}

int main(int argc, char** argv){
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(640,480);
    glutInitWindowPosition(200,200);
    glutCreateWindow("FloodFill Algorithm");
    glutDisplayFunc(world);
    glutMouseFunc(mouse);
    glutMotionFunc(drag_start);
    glutKeyboardFunc(key);
    init();
    glutMainLoop();
    return 0;
}
//First s then d

#include <iostream>
#include <math.h>
#include <time.h>
#include <GL/glut.h>

using namespace std;

int wxmin = 200,wxmax=500,wymax=350, wymin=100;
int points[10][2];
int edge;

void init(){
    glClearColor(1.0,1.0,1.0,0.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0,640,0,480);
    glClear(GL_COLOR_BUFFER_BIT);
}


void Draw(){
    glClearColor(1.0,1.0,1.0,0.0);
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(0.2,0.2,1);
    glBegin(GL_POLYGON);
        for(int i=0; i<edge; i++)
        {
            glVertex2i(points[i][0],points[i][1]);   
        }
    glEnd();
    glFlush();
    
    glColor3f(0,1,0);
    glBegin(GL_LINE_LOOP);
        glVertex2i(200,100);
        glVertex2i(500,100);
        glVertex2i(500,350);
		glVertex2i(200,350);
    glEnd();
    glFlush();

}
int BottomCliping(int e){

float m=0;
int x=0,k=0;
int t[10][2];

    for(int i=0; i<e; i++){
        if(points[i][1] < wymin){
           
            if(points[i+1][1]  < wymin){
           
            }
            else if(points[i+1][1] > wymin){
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
                x = ((1/((y2-y1)/(x2-x1))) * (wymin - y1) )+ x1;
                t[k][0] = x;
                t[k][1] = wymin;
                k++;
           
            }
       
        }
        else if(points[i][1]>wymin){
           
            if(points[i+1][1] > wymin){
                t[k][0] = points[i][0];
                t[k][1] = points[i][1];
                k++;
            }
            else if(points[i+1][1] < wymin){
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
       
                x = ((1/((y2-y1)/(x2-x1))) * (wymin - y1) )+ x1;
               
                t[k][0] = x1;
                t[k][1] = y1;
                k++;
                t[k][0] = x;
                t[k][1] = wymin;
                k++;
           
           
            }
       
        }
    
    }
    cout<<"k = "<<k;
    for(int i=0; i<10;i++)
    {
        points[i][0] = 0;
        points[i][1] = 0;
    
    }
    
    for(int i=0; i<k;i++)
    {
        cout<<"\n"<<t[i][0]<<" "<<t[i][1];
        points[i][0] = t[i][0];
        points[i][1] = t[i][1];
    
    }
    points[k][0] = points[0][0];
    points[k][1] = points[0][1];
    return k;

}





int TopCliping(int e){

float m=0;
int x=0,k=0;
int t[10][2];

    for(int i=0; i<e; i++){
        if(points[i][1] > wymax){
           
            if(points[i+1][1]  > wymax){
           
            }
            else if(points[i+1][1] < wymax){
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
                x = ((1/((y2-y1)/(x2-x1))) * (wymax - y1) )+ x1;
                t[k][0] = x;
                t[k][1] = wymax;
                k++;
           	
            }
       
        }
        else if(points[i][1]<wymax){
           
            if(points[i+1][1] < wymax){
                t[k][0] = points[i][0];
                t[k][1] = points[i][1];
                k++;
            }
            else if(points[i+1][1] > wymax){
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
       
                x = ((1/((y2-y1)/(x2-x1))) * (wymax - y1) )+ x1;
               
                t[k][0] = x1;
                t[k][1] = y1;
                k++;
                t[k][0] = x;
                t[k][1] = wymax;
                k++;
           
           
            }
       
        }
    
    }
    cout<<"k = "<<k;
    for(int i=0; i<10;i++)
    {
        points[i][0] = 0;
        points[i][1] = 0;
    
    }
    
    for(int i=0; i<k;i++)
    {
        cout<<"\n"<<t[i][0]<<" "<<t[i][1];
        points[i][0] = t[i][0];
        points[i][1] = t[i][1];
    
    }
    points[k][0] = points[0][0];
    points[k][1] = points[0][1];
    return k;

}

int leftCliping(int e){

float m=0;
int y=0, k = 0;
int t[10][2];
    for(int i=0;i<e;i++)
    {
    
        if(points[i][0] < wxmin){
       
            if(points[i+1][0] < wxmin){
                cout<<"\n Test 1";                                   
           
            }
            else if (points[i+1][0] > wxmin){
                cout<<"\n Test 2";
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
                y = (((y2-y1)/(x2-x1)) * (wxmin - x1) )+ y1;
                t[k][0] = wxmin;
                t[k][1] = y;
                k++;   
            }
        }
        else if(points[i][0] > wxmin){
       
            if(points[i+1][0] > wxmin){
               
                t[k][0] = points[i][0];
                t[k][1] = points[i][1];
                k++;
            }
            else if(points[i+1][0] < wxmin){
           
               
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
       
                y = ((y2-y1)/(x2-x1)*(wxmin - x1)) + y1;
               
                t[k][0] = x1;
                t[k][1] = y1;
                k++;
                t[k][0] = wxmin;
                t[k][1] = y;
                k++;
            }
           
       
        }   
    }
    cout<<"k = "<<k;
    for(int i=0; i<10;i++)
    {
        points[i][0] = 0;
        points[i][1] = 0;
    
    }
    
    for(int i=0; i<k;i++)
    {
        cout<<"\n"<<t[i][0]<<" "<<t[i][1];
        points[i][0] = t[i][0];
        points[i][1] = t[i][1];
    
    }
    points[k][0] = points[0][0];
    points[k][1] = points[0][1];
    return k;
}

int RightCliping(int e){
float m=0;
int y=0, k = 0;
int t[10][2];
    for(int i=0;i<e;i++)
    {
    
        if(points[i][0] > wxmax){
       
            if(points[i+1][0] > wxmax){
                                                   
           
            }
            else if(points[i+1][0] < wxmax){
               
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
                y = (((y2-y1)/(x2-x1)) * (wxmax - x1) )+ y1;
                t[k][0] = wxmax;
                t[k][1] = y;
                k++;
            }
           
        }
        else if(points[i][0] < wxmax){
       
            if(points[i+1][0] < wxmax){
               
                t[k][0] = points[i][0];
                t[k][1] = points[i][1];
                k++;
            }
            else if(points[i+1][0] > wxmax){
           
                float x1,x2;
                float y1,y2;
                x1 = points[i][0];
                y1 = points[i][1];
                x2 = points[i+1][0];
                y2 = points[i+1][1];
       
                y = ((y2-y1)/(x2-x1)*(wxmax - x1)) + y1;
                t[k][0] = x1;
                t[k][1] = y1;
                k++;
                t[k][0] = wxmax;
                t[k][1] = y;
                k++;
            }   
        }   
    }
    cout<<"k = "<<k;
    for(int i=0; i<10;i++)
    {
        points[i][0] = 0;
        points[i][1] = 0;
    
    }   
    for(int i=0; i<k;i++)
    {
        cout<<"\n"<<t[i][0]<<" "<<t[i][1];
        points[i][0] = t[i][0];
        points[i][1] = t[i][1];
    
    }
    points[k][0] = points[0][0];
    points[k][1] = points[0][1];
    return k;
}

void P_C(){

    Draw();
}


void goMenu(int value){

    switch(value){
    
        case 1:
            edge = leftCliping(edge);
            Draw();
            break;
        case 2:
            edge = RightCliping(edge);
            Draw();
            break;
        case 3:
            edge = TopCliping(edge);
            Draw();
            break;
        case 4:
            edge = BottomCliping(edge);
            Draw();
            break;
    
    }
    glutPostRedisplay();
}

int main(int argc, char** argv){


    cout<<"\n Enter No of edges of polygon  ";
    cin>>edge;
    
    for(int i=0;i<edge;i++){
    
        cout<<"\n Enter point "<<i<<" x space y ";
        cin>>points[i][0]>>points[i][1];
    
    }
    points[edge][0] = points[0][0];
    points[edge][1] = points[0][1];
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(640,480);
    glutInitWindowPosition(200,200);
    glutCreateWindow("Polygon Clipping");
    init();   
    
    glutCreateMenu(goMenu);

         glutAddMenuEntry("Left",1);
         glutAddMenuEntry("Right",2);
         glutAddMenuEntry("Top",3);
         glutAddMenuEntry("Bottom",4);
         glutAttachMenu(GLUT_RIGHT_BUTTON);
    
        glutDisplayFunc(P_C); 
    
    glutMainLoop();
    return 0;
}
// 4 200 170 600 250 400 250 400 50 200 116



#include <GL/glut.h>
#include <iostream>
#include <math.h>
#include <vector>
#include <algorithm>

using namespace std;

int ch = 0;
vector<int> arr;
int ct = 0;
float colorarr[] = {1.0,0.0,0.0};
float flc[] = {};
float neg[] = {0.0,1.0,1.0};
void copyarr(float* arr1){
	for(int i=0; i<3; i++){
		flc[i] = arr1[i];
		if(arr1[i] == 0.0f){
			neg[i] = 1.0f;
		}
		if(arr1[i] == 1.0f){
			neg[i] = 0.0f;
		}
	}
}

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float* flc){
    glColor3f(flc[0],flc[1],flc[2]);
	glLineWidth(3);
    glBegin(GL_LINE_LOOP);
	glVertex2i(x1,y1);	
	glVertex2i(x2,y2);	
	glVertex2i(x3,y3);
    glEnd();
	glLineWidth(1);
	glFlush();
}


void drawQuadritaleral(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, float* flc){
    glColor3f(flc[0],flc[1],flc[2]);
	glLineWidth(3);
    glBegin(GL_LINE_LOOP);
	glVertex2i(x1,y1);	
	glVertex2i(x2,y2);	
	glVertex2i(x3,y3);
	glVertex2i(x4,y4);
    glEnd();
	glLineWidth(1);
	glFlush();
}

void TrnsScaling(vector<int> arr){
	vector<int> sarr;
	int sz = arr.size();
	float Sx, Sy;
	cout << "Enter Sx scaling factor: ";
	cin >> Sx;
	cout << "Enter Sy scaling factor: ";
	cin >> Sy;
	for(int i=0; i<sz; i++){
		if(i % 2 == 0){
			sarr.push_back(arr.at(i)*Sx);
		}
		if(i % 2 == 1){
			sarr.push_back(arr.at(i)*Sy);
		}
	}
	if (sz == 6){
		drawTriangle(sarr.at(0),sarr.at(1),sarr.at(2),sarr.at(3),sarr.at(4),sarr.at(5),neg);
	}

	
	else if(sz == 7){
		drawQuadritaleral(sarr.at(0),sarr.at(1),sarr.at(2),sarr.at(3),sarr.at(4),sarr.at(5),sarr.at(6),sarr.at(7),neg);
	}
	sarr.clear();
}

void Rotationabtpt(vector<int> arr, int x, int y){
	int xr = x;
	int yr = y; 
	int angle;
	cout << "Enter angle in degree's to rotate: ";
    cin >> angle;
    float theta = angle * M_PI / 180;
	vector<int> sarr;
	int sz = arr.size();
	for(int i=0; i<sz; i++){
		if(i % 2 == 0){
			int nx = xr + ((arr.at(i) - xr)*cos(theta)) - ((arr.at(i+1) - yr)*sin(theta));
			sarr.push_back(nx);
		}
		if(i % 2 == 1){
			int ny = yr + ((arr.at(i-1) - xr)*sin(theta)) + ((arr.at(i) - yr)*cos(theta));
			sarr.push_back(ny);
		}
	}
	if (sz == 6){
		drawTriangle(sarr.at(0),sarr.at(1),sarr.at(2),sarr.at(3),sarr.at(4),sarr.at(5),neg);
	}
	
	else if(sz == 8){
		drawQuadritaleral(sarr.at(0),sarr.at(1),sarr.at(2),sarr.at(3),sarr.at(4),sarr.at(5),sarr.at(6),sarr.at(7),neg);
	}
	sarr.clear();
}

void mouse(int button, int state, int x, int y)
{
	static int xx, yy;
	xx = x - 300;
	yy = 300 - y;
	int sz = arr.size();
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
    {
        if (ch == 1)
		{
			if (sz < 6){
				arr.push_back(xx);
				arr.push_back(yy);
			}
			sz = arr.size();
			if (sz == 6){
            	drawTriangle(arr.at(0),arr.at(1),arr.at(2),arr.at(3),arr.at(4),arr.at(5),flc);
			}
        }
        if (ch == 2)
		{
			if (sz < 4){
				arr.push_back(xx);
				arr.push_back(yy);
			}
			sz = arr.size();
			
        }
        if (ch == 3)
		{
			if (sz < 8){
				arr.push_back(xx);
				arr.push_back(yy);
			}
			sz = arr.size();
			if (sz == 8){
            	drawQuadritaleral(arr.at(0),arr.at(1),arr.at(2),arr.at(3),arr.at(4),arr.at(5),arr.at(6),arr.at(7),flc);
			}
        }
        if (ch == 4)
		{
			Rotationabtpt(arr, xx, yy);
        }
    }
    else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
	{
		if(ct % 3 == 0){
			colorarr[0] = 1.0;
			colorarr[1] = 0.0;
			colorarr[2] = 0.0;
			cout << "Red color is choosen" << endl;
		}
		else if(ct % 3 == 1){
			colorarr[0] = 0.0;
			colorarr[1] = 1.0;
			colorarr[2] = 0.0;
			cout << "Green  color is choosen" << endl;
		}
		else if(ct % 3 == 2){
			colorarr[0] = 0.0;
			colorarr[1] = 0.0;
			colorarr[2] = 1.0;
			cout << "Blue  color is choosen" << endl;
		}
		ct++;
	}
    glFlush();
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
		case 't':
		{
			ch = 1;
			copyarr(colorarr);
			cout << "Triangle is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 'c':
		{
			ch = 2;
			copyarr(colorarr);
			cout << "Circle is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 'q':
		{
			ch = 3;
			copyarr(colorarr);
			cout << "Quadrilateral is opted" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 's':
		{
			copyarr(colorarr);
			cout << "Scaling Transformation is opted" << endl;
			TrnsScaling(arr);
			break;
		}
		
		case 'R':
		{
			ch = 4;
			copyarr(colorarr);
			cout << "Rotation about any arbitary point is opted" << endl;
			glutMouseFunc(mouse);
			cout << "Click on the arbitary point" << endl;
			break;
		}
	
		case 'x':
		{
			arr.clear();
			cout << "Queue is cleared" << endl;
			break;
		}
		case 'X':
		{
			arr.clear();
			glClearColor(1.0, 1.0, 1.0, 1.0);
    		glClear(GL_COLOR_BUFFER_BIT);
			cout << "Screen is cleared" << endl;
			break;
		}
    }
    glutPostRedisplay();
}

void initialize()
{
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT);
    gluOrtho2D(-300, 300, -300, 300);
}

void initialaxis(){
	glColor3f(0,0,0);
	glLineWidth(2);
    glBegin(GL_LINES);
	glVertex2i(-300,0);	
	glVertex2i(300,0);	
	glVertex2i(0,-300);	
	glVertex2i(0,300);	
    glEnd();
	glFlush();
    glutKeyboardFunc(keyboard);
}

int main(int argc, char **argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE);
    glutInitWindowSize(600, 600);
    glutInitWindowPosition(800, 100);
    glutCreateWindow("Filling Algorithm");
	initialize();
    cout << "Choose your Line type: " << endl;
    cout << "--------------------------------------------" << endl;
    cout << "t => Triangle" << endl;
    cout << "c => Circle" << endl;
    cout << "q => Quadrilateral" << endl;
    cout << "--------------------------------------------" << endl;
    cout << "s => Scaling" << endl;
    cout << "r => Rotation about center" << endl;
    cout << "R => Rotation about point" << endl;
    
	cout << "--------------------------------------------" << endl;
	cout << "x => clear the queue" << endl;
	cout << "X => clear the screen" << endl;
	cout << "Right Click to change the color" << endl;
    cout << "--------------------------------------------" << endl;
    glutDisplayFunc(initialaxis);
    glutMainLoop();
    return 0;
}

#include <GL/freeglut.h>
#include <cmath>

const int WINDOW_WIDTH = 800;
const int WINDOW_HEIGHT = 800;
const int MAX_DEPTH = 1; // Maximum recursion depth for the snowflake

void drawKochSnowflake(float x1, float y1, float x2, float y2, int depth) {
    if (depth == 0) {
        // Base case: draw a line segment
        glBegin(GL_LINES);
        glVertex2f(x1, y1);
        glVertex2f(x2, y2);
        glEnd();
    } else {
        // Recursive case: divide the line segment into four parts and call the function recursively
        float deltaX = x2 - x1;
        float deltaY = y2 - y1;
        float x3 = x1 + deltaX / 3;
        float y3 = y1 + deltaY / 3;
        float x4 = x1 + 2 * deltaX / 3;
        float y4 = y1 + 2 * deltaY / 3;
        float x5 = (x3 + x4) / 2 + (y4 - y3) * sqrt(3) / 2;
        float y5 = (y3 + y4) / 2 + (x3 - x4) * sqrt(3) / 2;

        // Recursively draw the four line segments
        drawKochSnowflake(x1, y1, x3, y3, depth - 1);
        drawKochSnowflake(x3, y3, x5, y5, depth - 1);
        drawKochSnowflake(x5, y5, x4, y4, depth - 1);
        drawKochSnowflake(x4, y4, x2, y2, depth - 1);
    }
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0); // Set color to white

    float centerX = WINDOW_WIDTH / 2;
    float centerY = WINDOW_HEIGHT / 2;
    float radius = WINDOW_HEIGHT / 3;

    // Calculate the initial coordinates of the Koch snowflake triangle
    float x1 = centerX - radius * sqrt(3) / 2;
    float y1 = centerY - radius / 2;
    float x2 = centerX + radius * sqrt(3) / 2;
    float y2 = y1;
    float x3 = centerX;
    float y3 = centerY + radius;

    // Draw the three line segments of the initial triangle
    drawKochSnowflake(x1, y1, x2, y2, MAX_DEPTH);
    drawKochSnowflake(x2, y2, x3, y3, MAX_DEPTH);
    drawKochSnowflake(x3, y3, x1, y1, MAX_DEPTH);

    glFlush();
}

void reshape(int width, int height) {
    glViewport(0, 0, width, height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, width, 0, height);
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);
    glutCreateWindow("Koch Snowflake");
    glClearColor(0.0, 0.0, 0.0, 1.0); // Set clear color to black
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMainLoop();
    return 0;
}


#include <iostream>
#include <math.h>
#include <time.h>
#include <GL/glut.h>

using namespace std;

int xx[4],yy[4];
int i = 0;
int ch;

void init(){
    glClearColor(1.0,1.0,1.0,0.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0,600,600,0);
    glClear(GL_COLOR_BUFFER_BIT);
}
void putpixel(double xt,double yt )
{
    glColor3f(1,0,0);
    glBegin(GL_POINTS);
    glVertex2d(xt,yt);
    glEnd();
    glFlush();
}

void Algorithm(){

    glColor3f(0,0,0);
    glBegin(GL_LINES);
        glVertex2i(xx[0],yy[0]);
        glVertex2i(xx[1],yy[1]);
        glVertex2i(xx[1],yy[1]);
        glVertex2i(xx[2],yy[2]);
        glVertex2i(xx[2],yy[2]);
        glVertex2i(xx[3],yy[3]);
    glEnd();
    glFlush();

    double t;
    for (t = 0.0; t < 1.0; t += 0.0005)
    {
        double xt = pow(1-t, 3) * xx[0] + 3 * t * pow(1-t, 2) * xx[1] + 3 * pow(t, 2) * (1-t) * xx[2] + pow(t, 3) * xx[3];
        double yt = pow(1-t, 3) * yy[0] + 3 * t * pow(1-t, 2) * yy[1] + 3 * pow(t, 2) * (1-t) * yy[2] + pow(t, 3) * yy[3];
        glColor3f(0,1,1);
        glPointSize(2);
        glBegin(GL_POINTS);
            glVertex2i(xt,yt);
        glEnd();
        glFlush();
    }
}

void mouse(int button, int state, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
    {
        if (ch == 1)
		{
            xx[i] = x;
            yy[i] = y;
            glColor3f(1,0,0);
            glPointSize(5);
            glBegin(GL_POINTS);
                glVertex2i(xx[i],yy[i]);
            glEnd();
            glFlush();
            i++;
        }
    }
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
		case 'c':
		{
			ch = 1;
			cout << "Choose points for polygon" << endl;
			glutMouseFunc(mouse);
			break;
		}
		case 'd':
		{
			ch = 2;
			cout << "Display the Bezier curve" << endl;
			if (i >= 3){
                cout << "Yes" << endl;
                Algorithm();
            }
			break;
		}
		case 'x':
		{
            for(int j=0; x <= i; j++){
                xx[j] = 0;
                yy[j] = 0;
            }
			cout << "Queue is cleared" << endl;
			break;
		}
		case 'X':
		{
			glClearColor(1.0, 1.0, 1.0, 1.0);
    		glClear(GL_COLOR_BUFFER_BIT);
			cout << "Screen is cleared" << endl;
			break;
		}
    }
    glutPostRedisplay();
}

void P_C() {
    glColor3f(0,0,0);
    glBegin(GL_POINTS);
	glVertex2i(0,0);	
    glEnd();
	glFlush();
    glutKeyboardFunc(keyboard);
}

int main(int argc, char** argv){    
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(600,600);
    glutInitWindowPosition(200,200);
    glutCreateWindow("Bezier 4 point");
    init();
    glutDisplayFunc(P_C);
    glutMainLoop();
    return 0;
}

// c then d


#include <GL/freeglut.h>
#include <iostream>
#include <cmath>

int x = 20, y = 200, uplimit = 250;
int flag = 0;

void display()
{
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(1.0f, 0.0f, 0.0f);
    glBegin(GL_LINES);
    glVertex2f(0, 400);
    glVertex2f(679, 400);
    glEnd();

    if (flag == 0)
    {
        y += 2;
        x += 1;
        if (y >= 385)
            flag = 1;
    }
    else if (flag == 1)
    {
        y -= 2;
        x += 1;
        if (y <= uplimit)
        {
            uplimit += 20;
            flag = 0;
        }
    }

    glColor3f(1.0f, 1.0f, 1.0f);
    glPushMatrix();
    glTranslatef(x, y, 0.0f);
    glBegin(GL_TRIANGLE_FAN);
    for (int i = 0; i < 360; i++)
    {
        float angle = i * 3.14159 / 180;
        float xPos = 15 * cos(angle);
        float yPos = 15 * sin(angle);
        glVertex2f(xPos, yPos);
    }
    glEnd();
    glPopMatrix();

    glutSwapBuffers();
}

void update(int value)
{
    glutPostRedisplay();
    glutTimerFunc(10, update, 0);
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(680, 400);
    glutCreateWindow("Bouncing Ball");

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 680, 0, 400);

    glutDisplayFunc(display);
    glutTimerFunc(10, update, 0);

    glutMainLoop();

    return 0;
}






